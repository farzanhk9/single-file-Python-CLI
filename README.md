#!/usr/bin/env python3
# File: link_builder.py
# Build clean WhatsApp/Instagram/Telegram/Email links + an HTML button snippet.
# UTF-8 safe, optional UTM params, and batch CSV mode. Standard library only.

import argparse, csv, os, re
from urllib.parse import quote_plus, urlencode, urlparse, urlunparse, parse_qsl

def ensure_dir(path: str):
    os.makedirs(path, exist_ok=True)

def normalize_phone(raw: str) -> str:
    """
    Normalize to international format without '+' and leading zeros.
    Examples:
      "09133015545" + country 98 -> "989133015545" (user may pass already full)
      "989133015545" -> "989133015545"
      "+98 913 301 5545" -> "989133015545"
    """
    if not raw: return ""
    s = re.sub(r"[^\d]", "", raw)
    if s.startswith("00"): s = s[2:]
    return s

def add_utm(url: str, source=None, medium=None, campaign=None, term=None, content=None) -> str:
    if not (source or medium or campaign or term or content):
        return url
    u = urlparse(url)
    q = dict(parse_qsl(u.query))
    if source:   q["utm_source"] = source
    if medium:   q["utm_medium"] = medium
    if campaign: q["utm_campaign"] = campaign
    if term:     q["utm_term"] = term
    if content:  q["utm_content"] = content
    new_q = urlencode(q, doseq=True)
    return urlunparse((u.scheme, u.netloc, u.path, u.params, new_q, u.fragment))

def wa_link(phone: str, text: str | None) -> str:
    """
    wa.me style (recommended):
      https://wa.me/<phone>?text=<encoded>
    """
    p = normalize_phone(phone)
    base = f"https://wa.me/{p}"
    if text:
        return f"{base}?text={quote_plus(text)}"
    return base

def wa_api_link(phone: str, text: str | None) -> str:
    """
    web WhatsApp API style:
      https://api.whatsapp.com/send?phone=<phone>&text=<encoded>
    """
    p = normalize_phone(phone)
    qs = {"phone": p}
    if text: qs["text"] = text
    return "https://api.whatsapp.com/send?" + urlencode(qs, doseq=True, quote_via=quote_plus)

def ig_link(handle_or_url: str) -> str:
    h = handle_or_url.strip()
    if not h: return ""
    if h.startswith("http://") or h.startswith("https://"):
        return h
    h = h.lstrip("@")
    return f"https://instagram.com/{h}"
    
def tg_link(user_or_channel: str) -> str:
    t = user_or_channel.strip()
    if not t: return ""
    t = t.lstrip("@")
    return f"https://t.me/{t}"

def email_link(addr: str, subject: str | None, body: str | None) -> str:
    if not addr: return ""
    qs = {}
    if subject: qs["subject"] = subject
    if body:    qs["body"] = body
    return "mailto:" + addr + (("?" + urlencode(qs, quote_via=quote_plus)) if qs else "")

def build_html_buttons(items: list[dict]) -> str:
    """
    items: [{label, href}]
    Minimal, copy-paste ready. Inline CSS for portability.
    """
    btns = []
    for it in items:
        if not it.get("href"): 
            continue
        label = it.get("label", "Open")
        href  = it.get("href")
        btns.append(
f'''<a href="{href}" target="_blank" rel="noopener" style="display:block;margin:10px 0;padding:14px 16px;border-radius:12px;text-decoration:none;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#111827;color:#e5e7eb;border:1px solid rgba(255,255,255,.08);text-align:center;">{label}</a>'''
        )
    wrapper = """<!-- Buttons generated by link_builder.py -->
<div style="max-width:520px;margin:0 auto;padding:20px;">
%s
</div>""" % ("\n".join(btns))
    return wrapper

def build_for_row(row: dict, utm: dict) -> dict:
    name    = (row.get("name") or "").strip()
    phone   = (row.get("phone") or "").strip()
    message = (row.get("message") or "").strip()
    ig      = (row.get("ig") or "").strip()
    tg      = (row.get("tg") or "").strip()
    email   = (row.get("email") or "").strip()
    subject = (row.get("subject") or "").strip()
    body    = (row.get("body") or "").strip()

    wa1 = add_utm(wa_link(phone, message), **utm) if phone else ""
    wa2 = add_utm(wa_api_link(phone, message), **utm) if phone else ""

    igu = add_utm(ig_link(ig), **utm) if ig else ""
    tgu = add_utm(tg_link(tg), **utm) if tg else ""
    eml = email_link(email, subject, body) if email else ""

    return {
        "name": name or "",
        "wa_me": wa1,
        "wa_api": wa2,
        "instagram": igu,
        "telegram": tgu,
        "email": eml
    }

def write_outputs(outdir: str, records: list[dict]):
    ensure_dir(outdir)
    # links.txt
    lines = []
    for r in records:
        title = f"[{r.get('name') or 'contact'}]"
        lines.append(title)
        for k in ("wa_me","wa_api","instagram","telegram","email"):
            if r.get(k):
                lines.append(f"{k}: {r[k]}")
        lines.append("")  # blank line
    with open(os.path.join(outdir, "links.txt"), "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    # buttons.html (use the first record if only one; for many, include all)
    items = []
    for r in records:
        label = r.get("name") or "Contact"
        if r.get("wa_me"):     items.append({"label": f"WhatsApp ({label})", "href": r["wa_me"]})
        if r.get("instagram"): items.append({"label": f"Instagram ({label})", "href": r["instagram"]})
        if r.get("telegram"):  items.append({"label": f"Telegram ({label})", "href": r["telegram"]})
        if r.get("email"):     items.append({"label": f"Email ({label})", "href": r["email"]})
    html = build_html_buttons(items)
    with open(os.path.join(outdir, "buttons.html"), "w", encoding="utf-8") as f:
        f.write(html)

def main():
    ap = argparse.ArgumentParser(description="Build WhatsApp / IG / Telegram / Email links + HTML buttons. UTF-8 safe.")
    ap.add_argument("--phone", help="Phone with country code (e.g., 989133015545)")
    ap.add_argument("--message", help="Message text (UTF-8 ok, will be URL-encoded)")
    ap.add_argument("--ig", help="Instagram handle or URL (e.g., kafsh_khanevadeh)")
    ap.add_argument("--tg", help="Telegram username/channel (e.g., mychannel)")
    ap.add_argument("--email", help="Email address")
    ap.add_argument("--subject", help="Email subject")
    ap.add_argument("--body", help="Email body")

    # UTM params (optional)
    ap.add_argument("--utm-source", dest="utm_source", default=None)
    ap.add_argument("--utm-medium", dest="utm_medium", default=None)
    ap.add_argument("--utm-campaign", dest="utm_campaign", default=None)
    ap.add_argument("--utm-term", dest="utm_term", default=None)
    ap.add_argument("--utm-content", dest="utm_content", default=None)

    # Batch CSV mode
    ap.add_argument("--csv", help="CSV with columns: name,phone,message,ig,tg,email,subject,body")

    ap.add_argument("--outdir", default="out", help="Output folder (links.txt, buttons.html)")
    args = ap.parse_args()

    utm = dict(source=args.utm_source, medium=args.utm_medium, campaign=args.utm_campaign,
               term=args.utm_term, content=args.utm_content)

    records = []

    if args.csv:
        with open(args.csv, "r", encoding="utf-8-sig") as f:
            reader = csv.DictReader(f)
            for row in reader:
                rec = build_for_row(row, utm)
                records.append(rec)

    else:
        row = {
            "name": "",
            "phone": args.phone or "",
            "message": args.message or "",
            "ig": args.ig or "",
            "tg": args.tg or "",
            "email": args.email or "",
            "subject": args.subject or "",
            "body": args.body or ""
        }
        rec = build_for_row(row, utm)
        records.append(rec)

    write_outputs(args.outdir, records)
    print(f"âœ… Saved {os.path.join(args.outdir,'links.txt')} and {os.path.join(args.outdir,'buttons.html')}")
    print("ðŸ’¡ Tip: paste buttons.html into your Link-in-Bio page or website.")

if __name__ == "__main__":
    main()
